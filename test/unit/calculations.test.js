
import { describe, it, expect, beforeEach } from 'vitest';

// We import the extracted logic.
// Note: This file is generated by test/prepare.js before tests run.
import { calculate, CONST, SEASON_WEIGHTS } from './app_logic.js';

describe('PowerPricing Calculations', () => {

    describe('calculate()', () => {
        it('should calculate Standard Plan correctly for Winter', () => {
            // Mock usage stats
            const usage = {
                totalKwh: 1000,
                onPeakKwh: 200, // Irrelevant for Standard but part of input
                offPeakKwh: 800,
                peakKw: 5,
                peakKwOff: 5
            };
            // Month 0 = Jan (Winter)
            const result = calculate(usage, '0');

            // Verify Standard Calculation
            const expectedDelivery =
                CONST.SC1_STD_FIXED +
                (1000 * (CONST.STD_DELIVERY_KWH + CONST.SBC_RATE));

            const expectedSupply =
                (1000 * CONST.SUPPLY_STD_WINTER) +
                (1000 * CONST.MFC_RATE);

            const expectedTotal =
                (expectedDelivery * CONST.TAX_DELIVERY) +
                (expectedSupply * CONST.TAX_SUPPLY);

            expect(result.stdTotal).toBeCloseTo(expectedTotal, 2);
        });

        it('should calculate Select Plan correctly for Summer', () => {
            // Mock usage stats
            const usage = {
                totalKwh: 1000,
                onPeakKwh: 300,
                offPeakKwh: 700,
                peakKw: 10,
                peakKwOff: 5
            };
            // Month 6 = July (Summer)
            const result = calculate(usage, '6');

            // Verify Select Calculation
            // Summer Demand Rate applies
            const demandCost = (10 * CONST.SUMMER_DEMAND) + (5 * CONST.DEMAND_OFF_PEAK);
            const deliveryVolCost = 1000 * (CONST.SEL_DELIVERY_KWH + CONST.SBC_RATE);

            const expectedDelivery = CONST.SC1_SEL_FIXED + demandCost + deliveryVolCost;

            const supplyOnCost = 300 * CONST.SUPPLY_SEL_ON;
            const supplyOffCost = 700 * CONST.SUPPLY_SEL_OFF;
            const mfcCost = 1000 * CONST.MFC_RATE;

            const expectedSupply = supplyOnCost + supplyOffCost + mfcCost;

            const expectedTotal =
                (expectedDelivery * CONST.TAX_DELIVERY) +
                (expectedSupply * CONST.TAX_SUPPLY);

            expect(result.selTotal).toBeCloseTo(expectedTotal, 2);
        });

        it('should correctly identify savings vs extra cost', () => {
            const usage = {
                totalKwh: 500,
                onPeakKwh: 0,
                offPeakKwh: 500,
                peakKw: 1,
                peakKwOff: 1
            };
            // Winter
            const result = calculate(usage, '0');

            // With 0 on-peak usage and low demand, Select SHOULD be cheaper
            expect(result.selTotal).toBeLessThan(result.stdTotal);
        });
    });

    describe('Constants Integirty', () => {
        it('should have season weights summing to approx 0.903', () => {
            const sum = SEASON_WEIGHTS.reduce((a, b) => a + b, 0);
            // Note: Weights sum to ~0.903, not 1.0. This implies ~10% of annual usage might be unaccounted for
            // in the distribution, or it's just an arbitrary relative scale.
            expect(sum).toBeCloseTo(0.903, 3);
        });
    });
});
